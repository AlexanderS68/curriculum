Wednesday, February 20, 2019
=====================
# Virtualenv
`virtualenv` is a pip package that allows us to create a virutal environment to develop our applications in. Virtual environments allow us the ability to install different versions of software without impacting other projects. It creates a per-project environment so there is no clashing between projects and your system. We'll be using `virtualenv` from here on out with Django projects.

## Installation and Usage
Let's get this installed:
```bash
$ pip install --upgrade pip
$ pip install virtualenv
```

Let's create a fresh project, `~/desktop/blog` using our virtual environment:
```bash
$ cd ~/Desktop
$ mkdir blog && cd blog
$ python -m venv venv
$ ls
```
You'll see a folder `venv` that contains everything related to the virtual environment. While you can name the virtual environment anything that you want, `venv` is the standard. Let's activate it as we start preparing our app:
```bash
$ source venv/bin/activate
```

You'll see your command prompt changes to have `(venv)` prepending it - you're now in a virtual environment! Let's get a fresh version of Django installed in our virtual environment:
```bash
$ python3 -m pip install --upgrade pip
$ touch requirements.txt
```

`requirements.txt` is a text file where you'll list out all of the requirements that your project needs - all the libraries that you need to install in order to run your project. Inside that file, add `Django~=2.1.3` (current as of December 2018) and run `pip install -r requirements.txt`. This installs Django in your virtual environment.

Let's move on to creating our CRUD blog. First make sure that you are in your folder ~/Desktop/blog and there is a `venv/` folder and `requirements.txt`. From there, run :
```bash
$ django-admin startproject mysite .
$ ls
```
The result should include: `manage.py*        mysite/           requirements.txt  venv/`

## Blog Models
Let's get our blog set up:
```bash
$ python manage.py startapp blog
```
We get our usual Django skeleton and now, we're going to get our models set up. We'll say that a blog has an author, title, text, and published_date. In `blog/models.py`, let's write:
```python
from django.conf import settings
from django.db import models

class Post(models.Model):
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    title = models.CharField(max_length=200)
    text = models.TextField()
    published_date = models.DateTimeField(blank=True, null=True)

    def __str__(self):
        return self.title
```
Let's get a migration into the database:
```bash
$ python manage.py makemigrations blog
```
Oops! We get an error! I think we forgot something - maybe registering our app to the project directory (`mysite/settings.py`)? Don't forget to register all your apps in your project! Add in our `blog` app there and let's move forward.

# Django Admin
One of the best features of Django is the ability to use their built-in admin dashboard to CRUD models in your database. We're going to use this today in `blog/admin.py`:
```python
from django.contrib import admin # brings in the admin ability
from .models import Post # brings in your Post model from the models.py file

admin.site.register(Post) # registers Post with your admin ability
```
Next, let's run all the migrations with your admin functionality and fire up the server:
```bash
$ python manage.py migrate
$ python manage.py runserver
```
If you visit http://localhost:8000/admin, you have a built-in dashboard. Try logging in and you realize that you haven't created a superuser yet:
```bash
$ python manage.py createsuperuser
```
Run through your setup, log in, and create 2-3 blog posts. It's super easy to CRUD blog posts as a super administrator and sometimes, this is all that you need. For us, that's a bit _too_ easy. We want to have the ability to CRUD without the admin panel. Let's get on that now.

## Urls / Views
First, we need to register your blog's URLs with the project's URLs:
```python
# urls.py
from django.urls import path, include
from django.contrib import admin

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
]
```
Next, create `blog/urls.py`:
```python
from django.urls import path
from . import views

urlpatterns = [
    path('posts', views.post_list, name='post_list'),
]
```
In `blog/views.py`, we need to get all of the code related to our views going:
```python
from django.shortcuts import render
from .models import Post

def post_list(request):
    posts = Post.objects.order_by('published_date')
    return render(request, 'blog/post_list.html', {'posts': posts})
```
We do all of the controller logic before passing off the objects from the database into the templates: `blog/templates/blog/post_list.html`
```html
<div>
  <h1><a href="/">My Blog</a></h1>
</div>

{% for post in posts %}
  <div>
      <h2><a href="">{{ post.title }}</a></h2>
      <p>published: {{ post.published_date }}</p>
      <p>{{ post.text|linebreaksbr }}</p>
  </div>
{% endfor %}
```
Visit http://localhost:3000/posts and see your ugly code. Let's style it in the next section

## Styling
Our website is functional, but it's also hideous. We are going to add Bootstrap to make it look nice with just a few lines of code. Let's add a few things to our `post_list.html` to get us started:
```html
<head>
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
</head>

<div>
  <h1><a href="/">My Blog</a></h1>
</div>

{% for post in posts %}
  <div>
      <h2><a href="">{{ post.title }}</a></h2>
      <p>published: {{ post.published_date }}</p>
      <p>{{ post.text|linebreaksbr }}</p>
  </div>
{% endfor %}
```
Next, we will need to create our first static file for custom CSS to make it look pretty under `blog/static/css/blog.css`:
```css
h1 a, h2 a {
    color: #C25100;
}

body {
    padding-left: 15px;
}
```
In our `post_list.html` file, we need to tell the file that we want to load some static files and will be bringing in external stylesheets:
```html
{% load static %}
<html>
  <head>
    <title>My Blog</title>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="{% static 'css/blog.css' %}">
  </head>

  <div>
    <h1><a href="/">My Blog</a></h1>
  </div>

  {% for post in posts %}
    <div>
        <h2><a href="">{{ post.title }}</a></h2>
        <p>published: {{ post.published_date }}</p>
        <p>{{ post.text|linebreaksbr }}</p>
    </div>
  {% endfor %}
</html>
```

Restart the server and see your slightly better looking website. It's good, but we want to make it look better. Let's bring in an external font to our header by adding `<link href="//fonts.googleapis.com/css?family=Lobster&subset=latin,latin-ext" rel="stylesheet" type="text/css">` to `post_list.html`'s head and `font-family: 'Lobster';` to the CSS for the h1/h2 tags. If you refresh the page now, it's got some fancy script going on.

We want to optimize our CSS by breaking down our page into different sections and writing CSS for those sections. We'll be creating a CSS for our header and for our post list. Let's wrap those `div`'s with class names in `post_list.html` and add a few CSS classes:
```html
{% load static %}
<html>
  <head>
    <title>My Blog</title>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="{% static 'css/blog.css' %}">
    <link href="//fonts.googleapis.com/css?family=Lobster&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  </head>

  <div class="page-header">
    <h1><a href="/">My Blog</a></h1>
  </div>

  <div class="content container">
    <div class="row">
        <div class="col-md-8">
            {% for post in posts %}
                <div class="post">
                    <div class="date">
                        <p>published: {{ post.published_date }}</p>
                    </div>
                    <h2><a href="">{{ post.title }}</a></h2>
                    <p>{{ post.text|linebreaksbr }}</p>
                </div>
            {% endfor %}
        </div>
    </div>
  </div>
</html>
```
Finally, let's change `blog.css`:
```css
.page-header {
    background-color: #C25100;
    margin-top: 0;
    padding: 20px 20px 20px 40px;
}

.page-header h1, .page-header h1 a, .page-header h1 a:visited, .page-header h1 a:active {
    color: #ffffff;
    font-size: 36pt;
    text-decoration: none;
}

.content {
    margin-left: 40px;
}

h1, h2, h3, h4 {
    font-family: 'Lobster', cursive;
}

.date {
    color: #828282;
}

.save {
    float: right;
}

.post-form textarea, .post-form input {
    width: 100%;
}

.top-menu, .top-menu:hover, .top-menu:visited {
    color: #ffffff;
    float: right;
    font-size: 26pt;
    margin-right: 20px;
}

.post {
    margin-bottom: 70px;
}

.post h1 a, .post h1 a:visited {
    color: #000000;
}
```
If you refresh the page, it looks amazing! Take a breather before moving onto the next section on templating.

## Templating
Template extending is the act of writing HTML/CSS one time (writing a template) and using it in other files/pages (extending). Think of Amazon - on every page

### Acknowledgements
This tutorial is largely based off [Django Girls](https://tutorial.djangogirls.org/) and we thank them for open-sourcing everything!