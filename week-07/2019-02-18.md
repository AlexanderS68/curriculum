Monday, February 18, 2019
=====================

# Introduction to Django
Django is the web framework for Python. As we've mentioned countless times, a library is nothing more than thousands of lines of code that someone else wrote ahead of time to make your job as a developer easier. A framework is merely a bunch of libraries woven together. In today's web, we generally have a framework taking care of the backend (e.g., Django, Rails, Node) and a framework taking care of the frontend (e.g., React, Angular, Backbone). While there isn't a production-grade single solution for the front/back-end, there are situations where a single framework is preferable (e.g., getting a pet project off the ground quickly, proof of concept, etc.)

Today, we're going to get started with using Django as a full stack framework, handling both the front and back end of our application. Later, we'll learn how to run Django just as an API (backend) layer and use it in conjunction with React on the frontend.

## Setup
This tutorial is largely based off of [the official docs](https://docs.djangoproject.com/en/2.1/intro/tutorial01/). A few things have been removed for brevity and others have been added to account for our current level of knowledge. If you prefer to use their tutorial, feel free to do so.

We need to see if we've got Django already installed before anything else:
```bash
$ python -m django --version
```

If you see a version number, you're all set and have installed Django in the past. If not, you'll see `No module named django`. In that case, let's go ahead and

```bash
$ pip install Django
```

Next, let's create an project called `mysite` in our Desktop (or wherever you typically store code):

```
$ django-admin startproject mysite
```

With that command, we've got the beginnings of our Django app. Here's the breakdown of each file with explanations from the docs and from us:
- `manage.py`
  - **Docs**: A command-line utility that lets you interact with this Django project in various ways
  - **Us**: It's code that allows you to use your terminal to interact with your app. This includes running migrations, interacting with the console, and starting the server. Don't worry about this file - it's given to us for free
- `mysite/__init__.py`
  - **Docs**: An empty file that tells Python that this directory should be considered a Python package
  - **Us**: It's a file with dunder (double underscores) in the filename that Python needs in order to run this properly
- `mysite/settings.py` 
  - **Docs**: Settings/configuration for this Django project
  - **Us**: Yeah, don't worry about this
- `mysite/urls.py` 
  - **Docs**: The URL declarations for this Django project; a “table of contents” of your Django-powered site. You can read more about URLs in URL dispatcher.
  - **Us**: This is the file where you declare (write) all your routes. Think of this as the phone operator of an organization. You call the operator and tell them what you want. Then, the operator directs to you to where you need to go
- `mysite/wsgi.py` 
  - **Docs**: An entry-point for WSGI-compatible web servers to serve your project
  - **Us**: A file that you need that you don't need know too much about. It's what we need to fire the app up on different types of servers

Let's fire up the server: `python manage.py runserver 8000` (or just `python manage.py runserver` if you know that you always want to use the 8000 port). Next, visit http://localhost:8000 and see what you get!


## Poll App / Views
In the same directory / level as `manage.py`, run:
```bash
$ python manage.py startapp polls
```

A quick sidebar - we ran `startproject` earlier and we are now running `startapp`. The difference between these two is that a `project` consists of many `apps`. An `app` can belong to many `projects`.

In `polls/views.py`, let's put the following code inside:
```python
from django.http import HttpResponse
from django.shortcuts import render

def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")
```

We created a request method called `index` inside the `views` file. Next, we need to register this page in `polls/urls.py`. Create that file and paste the following code in there:

```python
from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
]
```

Finally, we will connect our recently created `urls.py` to `mysite/urls.py`:

```python
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('polls/', include('polls.urls')),
    path('admin/', admin.site.urls),
]
```

Whoa, a lot of code just now - let's break it down. We started off earlier with creating a project called `mysite`. Projects can consist of many apps. We then created a `polls` app which is at the same level as `mysite`. Whenever anyone hits any route (aka endpoint) with `/polls`, the `mysite/urls.py` file will direct them to the `polls` app, specifically the `urls` file. From there, it'll send the user to `index` method in `views.py`.

In `polls/urls.py`, let's break down the `path` method that we imported. `path` takes in 4 arguments. 2 of them are required and 2 of them are optional. In order, they are `route`, `view`, and `kwargs` / `name`. `route` is the path that you enter in the URL. `view` is the file that handles the view. In our case, it is `views.index` or "Look at the index method in the `views.py` file." Finally, we passed in `name=index` to give us a `named route` to use later on.

Visit http://localhost:8000/polls to see what you get!

## Setting up our Database
Most companies use PostgreSQL as their production database and while we'll move onto that later, we're going to use SQLite3 today. SQLite3 is extraordinarily lightweight - it's essentially a file that you interact with using SQL.

Let's ensure that the `ENGINE` reads `'ENGINE': 'django.db.backends.sqlite3'` before running:
```bash
$ python manage.py migrate
```

### Models
Django is an MVC framework - Model, View, Controller. The Controller layer can be seen as the brains of the app; it handles the logic. The View layer is responsible for everything that a user sees, and the Model layer is what connects your Python objects to the database. In Django, we declare all of our models in one file: `models.py`. In polls/models.py, let's write:

```python
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
```

We've got two tables in our polls app: question and choice. A question has `question_text` and a `published_date`, and has many choices. A choice belongs to a question through the `ForeignKey(Question`, has `choice_text` and `votes`.

Next, we have to hook up our polls app to my_site's configuration in `mysite/settings.py`:
```python
INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```

Now we're ready to migrate the code we wrote into `models.py`:
```bash
$ python manage.py makemigrations polls
```

A new file was created for us: `polls/migrations/0001_initial.py`. Every time that you run `python manage.py makemigrations`, it will detect differences and save it was a numbered migration under your `migrations` folder. This allows you to store changes to your models and ultimately your database schema over time. 

Finally, to get our code into the database:
```bash
$ python manage.py migrate
```
